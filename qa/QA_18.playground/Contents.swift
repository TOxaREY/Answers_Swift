import UIKit
import PlaygroundSupport

var downloadedData: Data?

func downloadData(completion: @escaping (Data?) -> Void) {
    
    let url = URL(string: "https://google.com")!
    let task = URLSession.shared.dataTask(with: url) { (data, response, error) in
        guard let data = data else { return }
        downloadedData = data
        completion(downloadedData)
    }
    task.resume()
    
}
downloadData { _ in
    print(downloadedData!) //15521 bytes
}

/*
 Как и большинство сетевых API, NSURLSessionAPI является очень асинхронным.
 Он возвращает данные в ваше приложение одним из двух способов,
 в зависимости от методов, которые вы вызываете:

 ●  Вызывая блок обработчика completion, когда передача заканчивается успешно или с ошибкой.

 ●  Вызывая методы делегата сеанса по мере поступления данных и по завершении передачи.
 
 После создания задачи вы запускаете ее, вызывая ее resume() метод.
 Задачи начинаются в приостановленном состоянии,
 поэтому вам нужно вызвать этот метод(resume()), чтобы запустить задачу.
 
 Принудительное развертывание после инициализатора URL небезопасно,
 так как, если string "", код не компилируется.
 
 downloadedData ненужно инициализировать, результат будет определен в проверке
 guard let data = data else { return }, что присвоет downloadedData значение
 или произойдет выход из функции. Но чтобы получить данные, нужно downloadedData
 вывести из функции и данные передадут через @escaping completion.
 
 Согласно документации Apple, вы обязаны пометить замыкание,
 передаваемое в функцию в качестве параметра,
 ключевым словом @escaping, если оно будет вызвано после возвращения из функции.
 */



/*
 □ В этом нет ничего плохого, поэтому этот код будет работать, как и ожидалось.

 ■ API URLSession является асинхронным, поэтому мы должны вызывать последний completion после завершения задачи с данными.

 □ Задача данных возобновляется (resumed) автоматически при ее создании, поэтому вызов возобновления (resume) вручную приведет к тому, что запрос будет отправлен дважды.

 ■ Принудительное развертывание (force-unwrap) после инициализатора URL небезопасно.

 ■ Нам нужно проверить, что полученные данные на nil, чтобы предотвратить возможный сбой.

 □ Забыли инициализировать downloadedData, поэтому результат может быть неопределенным.

 ■ Аргумент закрытия (completion) замыкания должен быть помечен как @escaping.
 */

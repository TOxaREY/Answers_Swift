import UIKit
import PlaygroundSupport


/*
 ConcurrentQueue(параллельная) очередь создается с меткой и атрибутом
 let concurrentQueue = DispatchQueue(label: "queuename", attributes: .concurrent)
 SerialQueue(последовательная) очередь создается только с меткой
 let serialQueue = DispatchQueue(label: "queuename")
 */
1 //Перед нами последовательные очереди
let main = DispatchQueue(label: "main") //main и background здесь просто метки
let background = DispatchQueue(label: "background") //они не имеют отношение к главной
                                                    //и соответственно глобальной очередям

2 //После async управление передается вызывающему потоку
main.async {
    3 //Последовательно вызван "1"
    print("1")
    4 //Sync блокирует вызывающий поток (последовательное выполнение) в другой очереди
    background.sync {
        5 //Пауза 1 секунда
        sleep(1)
        6 //Вызван "2"
        print("2")
        7 //Всякая последовательная очередь ждёт выполнения текущей задачи,
          /*перед тем как начать выполнять следующую. Когда мы пытаемся СИНХРОННО поставить
          в очередь текущую задачу, мы получаем блокировку. Это происходит потому, что
          когда мы выполняем код main.sync {}, то мы это делаем в рамках текущей, уже выполняющейся
          в очереди задачи (background.sync {}) И пытаемся синхронно добавить задачу.
          Синхронно означает, что мы должны дождаться завершения текущей задачи.
          Но как мы можем завершить задачу в которой сами же и находимся, если мы сами
          её и тормозим (встаем на пути выполнения)? Взаимоблокировка. Всё deadlock.
          */
        main.sync {
            print("3")
        }
    }
    print("4")
}


/*
 ○ 1 2 3 4

 ● 1 2

 ○ 1 4 2 3

 ○ Порядок чисел, появляющихся на консоли, является неопределенным из-за асинхронных
 операций, но «1» будет напечатан первым.

 ○ В приложении не может быть другого основного потока (main thread),
 и код будет зависать (crash) при инициализации первого DispatchQueue.
 */



